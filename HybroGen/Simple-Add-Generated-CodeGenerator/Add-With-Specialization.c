/* Begin Header autogenerated part */
#ifndef H2_COMMON
#define H2_COMMON

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdbool.h>
#ifdef H2SYS
#include <sys/mman.h>
#endif

bool h2_codeGenerationOK;

typedef struct
{
  int ValOrReg; // Boolean
  char arith;
  int vLen;
  int wLen;
  int regNro;
  int valueImm;
} h2_sValue_t;


enum ARCH_LIST {X86, RISCV, POWER,  K1,};
enum RISCV_VARIANT {RV32I,};
typedef enum {
    REGISTER,
    VALUE,
} VALORREG;

typedef union {
    float f;
    unsigned long i;
} h2_float_int_u;

#endif /*H2_COMMON*/
#ifndef H2_RISCV
#define H2_RISCV

#include <stdint.h>

typedef uint32_t      h2_insn_t;
static  h2_insn_t   *h2_asm_pc;
static  h2_insn_t    *h2_save_asm_pc;

static void h2_iflush(void *addr, void *last)
{
#ifdef H2SYS
    long pageSize= getpagesize();
    void *ptmp= (char *)((long)addr & ~(pageSize - 1));
    if (mprotect(ptmp, (last - addr), PROT_READ | PROT_WRITE | PROT_EXEC))
    {
        perror("iflush: mprotect");
        exit(-1);
    }
#endif
#ifdef ASM_DEBUG
    printf("Flush data cache from %p to %p\n", addr, last);
#endif
	if (!h2_codeGenerationOK)
	  {
		fprintf (stderr, "(iflush) Failed code generation\n");
		exit(-5);
	  }
}

static h2_insn_t *h2_malloc (size_t size)
{
  return malloc (size);
}


#endif /*H2_RISCV*/

#define riscv_G32(INSN){ *(h2_asm_pc++) = (INSN);}

#define RV32I_RET__I_32_1() /* RET */ \
do { \
	riscv_G32(((0x8067 >> 0) & 0xffffffff)); \
} while(0)

#define RV32I_ADDI_RRI_I_32_1(r1,r0,i0) /* ADD */ \
do { \
	riscv_G32(((i0 & 0xfff) << 20)|((r0 & 0x1f) << 15)|((0x0 & 0x7) << 12)|((r1 & 0x1f) << 7)|((0x13 & 0x7f) >> 0)); \
} while(0)

#define RV32I_ADD_RRR_I_32_1(r3,r1,r2) /* ADD */ \
do { \
	riscv_G32(((0x0 & 0x7f) << 25)|((r2 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x0 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x33 & 0x7f) >> 0)); \
} while(0)

#define RV32I_MV_RR_I_32_1(r0,r1) /* MV */ \
do { \
	riscv_G32(((0x0 & 0xfff) << 20)|((r1 & 0x1f) << 15)|((0x0 & 0x7) << 12)|((r0 & 0x1f) << 7)|((0x13 & 0x7f) >> 0)); \
} while(0)

#define RV32I_MV_RI_I_32_1(r3,i1) /* MV */ \
do { \
	riscv_G32(((i1 & 0xfff) << 20)|((0x6 & 0xff) << 12)|((r3 & 0x1f) << 7)|((0x13 & 0x7f) >> 0)); \
} while(0)
void riscv_genRET_0()
{

    RV32I_RET__I_32_1();

}
void riscv_genADD_3(h2_sValue_t P0, h2_sValue_t P1, h2_sValue_t P2)
{

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
        RV32I_ADDI_RRI_I_32_1(P0.regNro, P1.regNro, P2.valueImm);
    }

    else if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
        RV32I_ADD_RRR_I_32_1(P0.regNro, P1.regNro, P2.regNro);
    }

    else
    {
        printf("Warning, generation of ADD is not possible with this arguments P0: %c, %i, %i,  P0: %i , P1: %i , P2: %i \n", P0.arith, P0.wLen, P0.vLen, P0.ValOrReg ,P1.ValOrReg ,P2.ValOrReg);
        h2_codeGenerationOK = false;
    }
}
void riscv_genMV_2(h2_sValue_t P0, h2_sValue_t P1)
{

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER)
    {
        RV32I_MV_RR_I_32_1(P0.regNro, P1.regNro);
    }

    else if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == VALUE)
    {
        RV32I_MV_RI_I_32_1(P0.regNro, P1.valueImm);
    }

    else
    {
        printf("Warning, generation of MV is not possible with this arguments P0: %c, %i, %i,  P0: %i , P1: %i \n", P0.arith, P0.wLen, P0.vLen, P0.ValOrReg ,P1.ValOrReg);
        h2_codeGenerationOK = false;
    }
}

/* End Header autogenerated part */
#include <stdio.h> // -*- c -*-
#include <stdlib.h>

typedef  int (*pifi)(int);

h2_insn_t * genAdd(h2_insn_t * ptr, int  b)
{
/* Code Generation of 4 instructions */
/* Symbol table :*/
	/*VarName = { ValOrLen, arith, vectorLen, wordLen, regNo, Value} */
	h2_sValue_t a = {REGISTER, 'i', 1, 32, 10, 0};
	h2_sValue_t h2_outputVarName = {REGISTER, 'i', 1, 32, 10, 0};
	h2_sValue_t r = {REGISTER, 'i', 1, 32, 5, 0};
	h2_sValue_t h2_00000003 = {REGISTER, 'i', 1, 32, 6, 0};


/* Label  table :*/
#define riscv_genLABEL(LABEL_ID) labelAddresses[LABEL_ID] = h2_asm_pc;
h2_insn_t   * labelAddresses []={
	};


	h2_asm_pc = (h2_insn_t *) ptr;
	h2_codeGenerationOK = true;
	riscv_genMV_2(h2_00000003, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (b)});
	riscv_genADD_3(r, h2_00000003, a);
	riscv_genMV_2(h2_outputVarName, r);
	riscv_genRET_0();
	/* Call back code for loops */
	h2_save_asm_pc = h2_asm_pc;
	h2_asm_pc = h2_save_asm_pc;
	h2_iflush(ptr, h2_asm_pc);

  return (h2_insn_t *) ptr;
}

int main(int argc, char * argv[])
{
  h2_insn_t * ptr;
  int in0, in1, res;
  pifi fPtr;

  if (argc < 3)
    {
      printf("Give 2 values\n");
      exit(-1);
    }
  in0  = atoi (argv[1]);   // Get the users values in1 & in2
  in1  = atoi (argv[2]);
  ptr  = h2_malloc (1024);  // Allocate memory for 1024 instructions
  printf("// Compilette for simple addition between 1 variable with\n");
  printf("// code specialization on value = %d\n", in0);
  fPtr = (pifi) genAdd (ptr, in0); // Generate instructions
  res  = fPtr(in1);  // Call generated code
  printf("%d + %d = %d\n", in0, in1, res);
  if (res == (in0 + in1))
    return 0;
  else
    return -1;
}
